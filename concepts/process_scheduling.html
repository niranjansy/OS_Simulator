<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Process Scheduling</title>
        <!-- CSS only -->
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
        <link rel="stylesheet" href="concepts.css">
        <!-- JS, Popper.js, and jQuery -->
        <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
        <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>

    </head>
    <style>
        body {
            margin-left: 5%;
            margin-right: 2%;
            margin-bottom: 5%;
        }
    
        p {
            margin-left: 20px;
            margin-right: 20px;
            font-size: 17px;
        }
    
        h3 {
            margin-left: 20px;
        }
    
        h4 {
            margin-left: 20px;
        }
    
        hr {
            border-color: black;
            border-width: medium;
        }
    </style>    
    <body>
        <!-- Navbar -->
        <nav class="navbar navbar-expand-lg navbar-light bg-light">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarTogglerDemo01" aria-controls="navbarTogglerDemo01" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarTogglerDemo01">
                <ul class="navbar-nav mr-auto">
                    <li class="nav-item active">
                        <a class="nav-link" href="../home/home.html">Home <span class="sr-only">(current)</span></a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../about/studentInfo.html">About</a>
                    </li>
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                        Concepts
                        </a>
                        <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                            <a class="dropdown-item" href="disk_scheduling.html">Disk Scheduling</a>
                            <a class="dropdown-item" href="process_scheduling.html">Process Scheduling</a>
                            <a class="dropdown-item" href="../concepts/demand_paging.html">Demand Paging</a>
                            <a class="dropdown-item" href="../concepts/contiguous_memory_allocation.html">Contiguous Memory Allocation</a>
                            <a class="dropdown-item" href="file_allocation.html">File Allocation</a>
                            <a class="dropdown-item" href="deadlocks.html">Deadlocks</a>
                        </div>
                    </li>
                </ul>
    
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item active">
                        <a class="navbar-brand" href="https://nitk.ac.in">
                            <img src="https://www.noticebard.com/wp-content/uploads/2020/01/NITK-Surathkal.png">
                        </a>
                    </li>
                </ul>
            </div>
        </nav>  
        <br><br>
        <h1>Process Scheduling</h1>
        <hr style="border-width: thick;" />
        <h3>CPU Scheduler</h3>
        <p>
            Whenever the CPU becomes idle, the operating system must select one
            of the processes in the ready queue to be executed. The selection
            process is carried out by the short-term scheduler, or CPU
            scheduler. The scheduler selects a process from the processes in
            memory that are ready to execute and allocates the CPU to that
            process.
        </p>
        <h2>First Come First Serve</h2>
        
        <hr />
        <h3>Description</h3>
        <p>
            In the "First come first serve" scheduling algorithm, as the name suggests, the process which arrives first, gets
            executed first, or we can say that the process which requests the CPU first, gets the CPU allocated first.
        </p>
        <h3>Demerits</h3>
        <p>
            1.Average waiting time under FCFS policy is quite long.<br />
            2.A smaller process has to wait for a large amount of time before a
            bigger process that has been allocated CPU finishes its
            execution.<br />
            3.Not suitable for time sharing systems where each user gets a share
            of CPU at regular intervals.<br />
        </p>
        <h2>Shortest Job Scheduling</h2>
        <hr />
        <h3>Description</h3>
        <p>
            Shortest job first (SJF) or shortest job next, is a scheduling policy that selects the waiting process with the
            smallest
            execution time to execute next.
        </p>
        <h3>Demerits</h3>
        <p>
            1.It often cannot be implemented at the level of short-term CPU
            scheduling as there is no way to know the length of the next CPU
            burst.<br />
            2.The next CPU burst length is thereby approximated using
            statistical techniques like exponential average<br />
        </p>
        
        <h2>Shortest Remaining Time First</h2>
        <hr />
        <p>
            This is the preemptive version of Shortest Job First scheduling. A
            newly arrived process in the ready queue may have a burst time
            lesser than that of the current process getting executed. In such a
            case, the current process is preempted and the newly arrived process
            is scheduled to execute. Similar to SJF, FCFS is used to resolve the
            tie here.
        </p>
        <h2>Largest Job First Scheduling</h2>
        <hr />
        <h3>Description</h3>
        <p>
            This is the opposite of Shortest Job First scheduling. It selects
            for execution the process with the largest execution time. It can be
            preemptive or non preemptive.
        </p>
        <h3>Demerits</h3>
        <p>
            1.The disadvantage with this algorithm is the total execution time
            of the process must be known before the execution.<br />
            There is a chance for starvation of processes which have lesser
            execution time when the longer processes are continually added.<br />
        </p>
        <h2>Largest Remaining Time First Algorithm</h2>
        <hr />
        <p>It is the preemptive version of the Largest job first scheduling.</p>
        <h2>Non-preemptive priority scheduling</h2>
        <hr />
        <h3>Description</h3>
        <p>
            A more general case of the SJF scheduling where the priority was
            based on burst time. Each process is associated with a priority and
            CPU is allocated to the process with highest priority. Equal
            priority processes are scheduled in FCFS order. A newly arrived
            process is simply put in the ready queue based on its priority and
            does not interrupt the currently executing process.
        </p>
        <h3>Demerits</h3>
        <p>
            1.In a heavily loaded computer system, a steady stream of high
            priority processes can leave some low priority processes waiting for
            a long time. This is called as indefinite blocking or starvation.<br />
            2.A solution to the problem of indefinite blocking is called aging,
            where priorities of processes that wait in the system for a long
            time are increased.<br />
        </p>
        
        <h2>Preemptive priority scheduling</h2>
        <hr />
        <p>
            It is a preemptive version of the priority scheduling algorithm. The
            priority of newly arrived processes are compared with the currently
            executing process. If the priority is higher, then the currently
            executing process is preempted and the newly arrived process
            executes
        </p>
        <h2>Round-Robin scheduling</h2>
        <hr />
        <h3>Description</h3>
        <p>
            The ready queue is treated as a circular queue. The CPU scheduler
            goes around the queue, allocating the CPU to each of the processes a
            time period of 1 quantum. If the burst time left for a process is
            less than the time quantum, then the process will itself release the
            CPU voluntarily. If the burst time left is more than 1 time quantum,
            the timer for that process will go off and a context switch is
            forced. This algorithm is preemptive by its nature.
        </p>
        <h3>Performance</h3>
        <p>
            1.Performance depends heavily on the time quantum. A very large time
            quantum will it make it effectively an FCFS algorithms and a very
            short time quantum will force a very large number of context
            switches.<br />
            2.A rule of thumb is that 80% of the CPU bursts must be shorter than
            the time quantum.<br />
        </p>
        
        <h2>Highest Response Ratio Next</h2>
        <hr />
        <h3>Description</h3>
        <p>
            1.The response ratio of all the processes are calculated and the
            scheduler selects the process with the highest response ratio.<br />
            2.A process once selected will run till its completion.<br />
            3.Response ratio = (Waiting time so far + Burst Time)/Burst time.<br />
            4.Shortest processes are favoured. As the waiting time increases,
            the response ratio increases and the longer jobs can get past short
            jobs.<br />
        </p>
    </body>
</html>