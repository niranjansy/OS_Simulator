<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Demand Paging</title>
        <!-- CSS only -->
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
        <link rel="stylesheet" href="concepts.css">
        <!-- JS, Popper.js, and jQuery -->
        <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
        <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>

    </head>
    <body>
        <!-- Navbar -->
        <nav class="navbar navbar-expand-lg navbar-light bg-light">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarTogglerDemo01" aria-controls="navbarTogglerDemo01" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarTogglerDemo01">
                <ul class="navbar-nav mr-auto">
                    <li class="nav-item active">
                        <a class="nav-link" href="../home/home.html">Home <span class="sr-only">(current)</span></a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../about/studentInfo.html">About</a>
                    </li>
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                        Concepts
                        </a>
                        <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                            <a class="dropdown-item" href="disk_scheduling.html">Disk Scheduling</a>
                            <a class="dropdown-item" href="process_scheduling.html">Process Scheduling</a>
                            <a class="dropdown-item" href="../concepts/demand_paging.html">Demand Paging</a>
                            <a class="dropdown-item" href="../concepts/contiguous_memory_allocation.html">Contiguous Memory Allocation</a>
                            <a class="dropdown-item" href="file_allocation.html">File Allocation</a>
                            <a class="dropdown-item" href="deadlocks.html">Deadlocks</a>
                            <a class="dropdown-item" href="../concepts/syncronization.html">Process Synchronization</a> 
                        </div>
                    </li>
                </ul>
    
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item active">
                        <a class="navbar-brand" href="https://nitk.ac.in">
                            <img src="https://www.noticebard.com/wp-content/uploads/2020/01/NITK-Surathkal.png">
                        </a>
                    </li>
                </ul>
            </div>
        </nav>  
        <!--End of navigation bar-->

        <h1 class="page_title"><b>Demand Paging</b></h1>
        <br>
        <div class = "Content">
            <h2>Paging</h2>
            <p>Paging is a memory management scheme that eliminates the need for contiguous allocation of physical memory. This scheme permits the physical address space of a process to be non – contiguous. The basic method for implementing paging involves breaking physical memory into fixed-sized blocks called frames and breaking logical memory into blocks of the same size called pages. When a process is to be executed, its pages are loaded into any available memory frames from their source (a file system or the backing store).</p>
            <p>Every address generated by the CPU is divided into two parts: a page number (p) and a page offset (d). The page number is used as an index into a page table. The page table contains the base address of each page in physical memory. This base address is combined with the page offset to define the physical memory address that is sent to the memory unit.</p>
            <img src = images/Paging_Hardware.JPG alt = "Paging Hardware" width=1000 height=400>
            <br>

            <h2>Virtual Memory</h2>
            <p>Virtual memory is a technique that allows the execution of processes that are not completely in memory. Virtual memory involves the separation of logical memory as perceived by users from physical memory. This separation allows an extremely large virtual memory to be provided for programmers when only a smaller physical memory is available. By using virtual memory, a program would no longer be constrained by the amount of physical memory that is available. Users would be able to write programs for an extremely large virtual address space, simplifying the programming task.</p>
            <br>

            <h2>Demand Paging</h2>
            <p>Demand paging is a technique where the Operating System loads pages of a process into the main memory only as they are needed. This technique is commonly used in virtual memory systems. With demand-paged virtual memory, pages are loaded only when they are demanded during program execution. Pages that are never accessed are thus never loaded into physical memory. memory. The swapping in of pages into memory is done by a lazy swapper, which never swaps a page into memory unless that page is be needed.</p>
            <br>

            <h2>Page Replacement</h2>
            <p>While implementing demand paging, if a required page is not present in the memory, it is termed as a page fault, and that page has to be brought into the memory from the disk. The swapped in page mudt be placed in a free frame in the memory. However, if there is no free frame available in the memory, we use a page replacement algorithm to select a victim page. The victim page is written back into the disk and the required new page in stored in that frame, and the required changes are made to the page and frame tables. Below are the algorithms that can be used to select a victim page to be replaced. </p>
            <br>

            <ol>
                <li>
                    <h2>First In First Out (FIFO) Page Replacement</h2>
                    <p>The simplest page-replacement algorithm is a first-in, first-out (FIFO) algorithm. A FIFO replacement algorithm associates with each page the time when that page was brought into memory. When a page must be replaced, the oldest page is chosen.</p>
                    <img src = images/FIFO_page_replacement.JPG alt = "FIFO page-replacement algorithm." width=1000 height=250>
                    <br>
                </li>

                <li>
                    <h2>Least Recently Used (LRU) Page Replacement</h2>
                    <p>If we use the recent past as an approximation of the near future, then we can replace the page that has not been used for the longest period of time. This approach is the least recently used (LRU) algorithm. LRU replacement associates with each page the time of that page’s last use. When a page must be replaced, LRU chooses the page that has not been used for the longest period of time.</p>
                    <img src = images/LRU_Page_Replacement.JPG alt = "LRU page-replacement algorithm." width=1000 height=250>
                    <br>
                </li>

                <li>
                    <h2>Optimal Page Replacement</h2>
                    <p>In the optimal page replacement algorithm , we replace the page that will not be used for the longest period of time in future. Use of this page-replacement algorithm guarantees the lowest possible page-fault rate for a fixed number of frames.</p>
                    <img src = images/Optimal_Page_Replacement.JPG alt = "Optimal page-replacement algorithm." width=1000 height=250>
                    <br>
                </li>

                <li>
                    <h2>Second Chance (Clock) Page Replacement</h2>
                    <p>For each page in the main memory, we maintain a reference bit. When a page is loaded into the memory, its reference bit is set to 0. However subsequently, if there is a page hit that references that page, its reference bit is set to 1. The basic algorithm of second-chance replacement is a FIFO replacement algorithm. When a page has been selected, however, we inspect its reference bit. If the value is 0, we proceed to replace this page; but if the reference bit is set to 1, we give the page a second chance and move on to select the next FIFO page. When a page gets a second chance, its reference bit is cleared, and its arrival time is reset to the current time. Thus, a page that is given a second chance will not be replaced until all other pages have been replaced (or given second chances).In addition, if a page is used often enough to keep its reference bit set, it will never be replaced.</p>
                    <img src = images/Second_Chance_Page_Replacement.JPG alt = "Second Chance page-replacement algorithm." width=500 height=500>
                </li>
            </ol>

        </div>
        
        


    </body>
</html>